"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var devtoolsApp_exports = {};
__export(devtoolsApp_exports, {
  syncLocalStorageWithSettings: () => syncLocalStorageWithSettings
});
module.exports = __toCommonJS(devtoolsApp_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_os = __toESM(require("os"));
var import_net = __toESM(require("net"));
var import_playwright_core = require("playwright-core");
var import_utils = require("playwright-core/lib/utils");
var import_registry = require("playwright-core/lib/server/registry/index");
var import_registry2 = require("./registry");
var import_session = require("./session");
function readBody(request) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    request.on("data", (chunk) => chunks.push(chunk));
    request.on("end", () => {
      try {
        const text = Buffer.concat(chunks).toString();
        resolve(text ? JSON.parse(text) : {});
      } catch (e) {
        reject(e);
      }
    });
    request.on("error", reject);
  });
}
function sendJSON(response, data, statusCode = 200) {
  response.statusCode = statusCode;
  response.setHeader("Content-Type", "application/json");
  response.end(JSON.stringify(data));
}
async function handleApiRequest(clientInfo, request, response) {
  const url = new URL(request.url, `http://${request.headers.host}`);
  const apiPath = url.pathname;
  if (apiPath === "/api/sessions/list" && request.method === "GET") {
    const registry = await import_registry2.Registry.load();
    const sessions = [];
    for (const [, entries] of registry.entryMap()) {
      for (const entry of entries) {
        const session = new import_session.Session(clientInfo, entry.config);
        const canConnect = await session.canConnect();
        if (canConnect || entry.config.cli.persistent)
          sessions.push({ config: entry.config, canConnect });
      }
    }
    sendJSON(response, { sessions, clientInfo });
    return;
  }
  if (apiPath === "/api/sessions/close" && request.method === "POST") {
    const body = await readBody(request);
    if (!body.config)
      throw new Error('Missing "config" parameter');
    await new import_session.Session(clientInfo, body.config).stop();
    sendJSON(response, { success: true });
    return;
  }
  if (apiPath === "/api/sessions/delete-data" && request.method === "POST") {
    const body = await readBody(request);
    if (!body.config)
      throw new Error('Missing "config" parameter');
    await new import_session.Session(clientInfo, body.config).deleteData();
    sendJSON(response, { success: true });
    return;
  }
  if (apiPath === "/api/sessions/run" && request.method === "POST") {
    const body = await readBody(request);
    if (!body.config)
      throw new Error('Missing "config" parameter');
    if (!body.args)
      throw new Error('Missing "args" parameter');
    const result = await new import_session.Session(clientInfo, body.config).run(body.args);
    sendJSON(response, { result });
    return;
  }
  if (apiPath === "/api/sessions/devtools-start" && request.method === "POST") {
    const body = await readBody(request);
    if (!body.config)
      throw new Error('Missing "config" parameter');
    const result = await new import_session.Session(clientInfo, body.config).run({ _: ["devtools-start"] });
    const match = result.text.match(/Server is listening on: (.+)/);
    if (!match)
      throw new Error("Failed to parse screencast URL from: " + result.text);
    sendJSON(response, { url: match[1] });
    return;
  }
  response.statusCode = 404;
  response.end(JSON.stringify({ error: "Not found" }));
}
async function openDevToolsApp() {
  const httpServer = new import_utils.HttpServer();
  const libDir = require.resolve("playwright-core/package.json");
  const devtoolsDir = import_path.default.join(import_path.default.dirname(libDir), "lib/vite/devtools");
  const clientInfo = (0, import_registry2.createClientInfo)();
  httpServer.routePrefix("/api/", (request, response) => {
    handleApiRequest(clientInfo, request, response).catch((e) => {
      response.statusCode = 500;
      response.end(JSON.stringify({ error: e.message }));
    });
    return true;
  });
  httpServer.routePrefix("/", (request, response) => {
    const pathname = new URL(request.url, `http://${request.headers.host}`).pathname;
    const filePath = pathname === "/" ? "index.html" : pathname.substring(1);
    const resolved = import_path.default.join(devtoolsDir, filePath);
    if (!resolved.startsWith(devtoolsDir))
      return false;
    return httpServer.serveFile(request, response, resolved);
  });
  await httpServer.start();
  const url = httpServer.urlPrefix("human-readable");
  const { page } = await launchApp("devtools");
  await page.goto(url);
  return page;
}
async function launchApp(appName) {
  const channel = (0, import_registry.findChromiumChannelBestEffort)("javascript");
  const context = await import_playwright_core.chromium.launchPersistentContext("", {
    ignoreDefaultArgs: ["--enable-automation"],
    channel,
    headless: false,
    args: [
      "--app=data:text/html,",
      "--test-type=",
      `--window-size=1280,800`,
      `--window-position=100,100`
    ],
    viewport: null
  });
  const [page] = context.pages();
  if (process.platform === "darwin") {
    context.on("page", async (newPage) => {
      if (newPage.mainFrame().url() === "chrome://new-tab-page/") {
        await page.bringToFront();
        await newPage.close();
      }
    });
  }
  page.on("close", () => {
    (0, import_utils.gracefullyProcessExitDoNotHang)(0);
  });
  const image = await import_fs.default.promises.readFile(import_path.default.join(__dirname, "appIcon.png"));
  await page._setDockTile(image);
  await syncLocalStorageWithSettings(page, appName);
  return { context, page };
}
async function syncLocalStorageWithSettings(page, appName) {
  const settingsFile = import_path.default.join(import_registry.registryDirectory, ".settings", `${appName}.json`);
  await page.exposeBinding("_saveSerializedSettings", (_, settings2) => {
    import_fs.default.mkdirSync(import_path.default.dirname(settingsFile), { recursive: true });
    import_fs.default.writeFileSync(settingsFile, settings2);
  });
  const settings = await import_fs.default.promises.readFile(settingsFile, "utf-8").catch(() => "{}");
  await page.addInitScript(
    `(${String((settings2) => {
      if (location && location.protocol === "data:")
        return;
      if (window.top !== window)
        return;
      Object.entries(settings2).map(([k, v]) => localStorage[k] = v);
      window.saveSettings = () => {
        window._saveSerializedSettings(JSON.stringify({ ...localStorage }));
      };
    })})(${settings});
  `
  );
}
function socketsDirectory() {
  return process.env.PLAYWRIGHT_DAEMON_SOCKETS_DIR || import_path.default.join(import_os.default.tmpdir(), "playwright-cli");
}
function devtoolsSocketPath() {
  return process.platform === "win32" ? `\\\\.\\pipe\\playwright-devtools-${process.env.USERNAME || "default"}` : import_path.default.join(socketsDirectory(), "devtools.sock");
}
async function acquireSingleton() {
  const socketPath = devtoolsSocketPath();
  return await new Promise((resolve, reject) => {
    const server = import_net.default.createServer();
    server.listen(socketPath, () => resolve(server));
    server.on("error", (err) => {
      if (err.code !== "EADDRINUSE")
        return reject(err);
      const client = import_net.default.connect(socketPath, () => {
        client.write("bringToFront");
        client.end();
        reject(new Error("already running"));
      });
      client.on("error", () => {
        if (process.platform !== "win32")
          import_fs.default.unlinkSync(socketPath);
        server.listen(socketPath, () => resolve(server));
      });
    });
  });
}
async function main() {
  let server;
  process.on("exit", () => server?.close());
  try {
    server = await acquireSingleton();
  } catch {
    return;
  }
  const page = await openDevToolsApp();
  server.on("connection", (socket) => {
    socket.on("data", (data) => {
      if (data.toString() === "bringToFront")
        page?.bringToFront().catch(() => {
        });
    });
  });
}
void main();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  syncLocalStorageWithSettings
});
